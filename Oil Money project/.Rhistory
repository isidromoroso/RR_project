<<<<<<< HEAD
cat("Mejor alpha (l1_ratio):", best_alpha, "\n")
cat("Mejor lambda:", best_lambda, "\n")
cat("Intercepto:", intercept, "\n")
cat("Coeficientes:", round(coefs, 5), "\n")
# Calcular valores ajustados
df$sk_fit <- df$usd * coefs[1] +
df$gbp * coefs[2] +
df$eur * coefs[3] +
df$brent * coefs[4] +
intercept
# Calcular residuales
df$sk_residual <- df$nok - df$sk_fit
# Cargar librerías necesarias
library(dplyr)
# Establecer umbrales basados en 1 sigma del residual anterior a la fecha corte
residual_std <- sd(df$sk_residual[df$date < as.Date('2017-04-25')])
upper <- residual_std
lower <- -residual_std
# Crear el dataframe de señales a partir del 25 de abril de 2017
signals <- df %>%
filter(date >= as.Date('2017-04-25')) %>%
select(nok, usd, eur, gbp, brent, sk_fit, sk_residual)
# Renombrar la columna sk_fit a fitted
signals <- signals %>%
rename(fitted = sk_fit)
# Agregar columnas de bandas y señales
signals <- signals %>%
mutate(
upper = fitted + upper,
lower = fitted + lower,
`stop profit` = fitted + 2 * upper,
`stop loss` = fitted + 2 * lower,
signals = 0
)
# Oil Money NOK Strategy - R Translation
# Load required libraries
library(tidyverse)
library(lubridate)
library(glmnet)
# Load and prepare data
df <- read.csv("data/brent crude nokjpy.csv", check.names = FALSE)
colnames(df)[1] <- "date"
df$date <- as.Date(df$date, format = "%m/%d/%Y")
# Scatter plot NOK vs Brent
df %>%
filter(date < as.Date("2017-04-25")) %>%
ggplot(aes(x = brent, y = nok)) +
geom_point(color = "#5f0f4e", size = 0.8) +
labs(title = "NOK Brent Correlation", x = "Brent in JPY", y = "NOKJPY") +
theme_minimal()
# Dual-axis base plot function (mimics Python twin axes)
dual_base_plot <- function(data, y1_col, y2_col, y1_label, y2_label, title,
col1 = "#34262b", col2 = "#cb2800") {
# Set margins to allow right axis label
par(mar = c(5, 4, 4, 4) + 0.1)
# Plot first series
plot(data$date, data[[y1_col]], type = "l", col = col1,
xlab = "Date", ylab = y1_label, main = title)
# Overlay second series with no axes
par(new = TRUE)
plot(data$date, data[[y2_col]], type = "s", col = col2,
axes = FALSE, xlab = "", ylab = "")
axis(side = 4, col = col2, col.axis = col2)
mtext(y2_label, side = 4, line = 3, col = col2)
legend("bottomright", legend = c(y1_label, y2_label),
col = c(col1, col2), lty = 1, bty = "n")
}
# Use dual_base_plot for relationships
# NOK vs Interest Rate
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "interest rate",
y1_label = "NOKJPY", y2_label = "Interest Rate",
title = "NOK vs Interest Rate"
)
# NOK vs Brent
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "brent",
y1_label = "NOKJPY", y2_label = "Brent in JPY",
title = "NOK vs Brent"
)
# NOK vs GDP (quarterly) - smooth interpolation of GDP values
# Interpolate GDP to daily frequency
gdp_idx    <- which(!is.na(df$`gdp yoy`))
gdp_dates  <- df$date[gdp_idx]
gdp_values <- df$`gdp yoy`[gdp_idx]
# Create interpolation function
gdp_interp_fun <- approxfun(x = as.numeric(gdp_dates), y = gdp_values, method = "linear", rule = 2)
# Apply to all dates
df$gdp_smooth <- gdp_interp_fun(as.numeric(df$date))
# Prepare combined dataframe for plotting
gdp_plot_df <- df %>% filter(date < as.Date("2017-04-25")) %>% select(date, nok, gdp_smooth)
# Plot using dual_base_plot (base R)
dual_base_plot(
gdp_plot_df,
y1_col = "nok", y2_col = "gdp_smooth",
y1_label = "NOKJPY", y2_label = "GDP YoY %",
title = "NOK vs GDP (Interpolated)"
)
# Linear regression (OLS)) (OLS)
x0 <- df %>% select(usd, gbp, eur, brent)
y  <- df$nok
train_idx <- df$date < as.Date("2017-04-25")
ols_model <- lm(y[train_idx] ~ ., data = x0[train_idx, ])
print(summary(ols_model))
library(glmnet)
# Convertimos x0 y filtramos por fecha
fecha_corte <- as.Date('2017-04-25')
x0_filtrado <- as.matrix(subset(x0, index(x0) < fecha_corte))
y_filtrado <- y[index(x0) < fecha_corte]
# Definimos los mismos parámetros que en Python
l1_ratios <- c(0.01, 0.1, 0.5, 0.9, 0.99)  # alpha in glmnet
lambdas <- c(0.0001, 0.0005, 0.001, 0.01, 0.1, 1, 10)
# Buscar la mejor combinación de l1_ratio y lambda
best_model <- NULL
best_mse <- Inf
best_alpha <- NA
best_lambda <- NA
for (l1 in l1_ratios) {
set.seed(123)  # Reproducibilidad
fit <- cv.glmnet(x0_filtrado, y_filtrado,
alpha = l1,
lambda = lambdas,
standardize = TRUE,
intercept = TRUE,
nfolds = 5,
maxit = 5000)
if (min(fit$cvm) < best_mse) {
best_mse <- min(fit$cvm)
best_model <- fit
best_alpha <- l1
best_lambda <- fit$lambda.min
}
}
# Extraer coeficientes del mejor modelo
coef_best <- coef(best_model, s = "lambda.min")
intercept <- coef_best[1]
coefs <- as.vector(coef_best[-1])
cat("Mejor alpha (l1_ratio):", best_alpha, "\n")
cat("Mejor lambda:", best_lambda, "\n")
cat("Intercepto:", intercept, "\n")
cat("Coeficientes:", round(coefs, 5), "\n")
# Calcular valores ajustados
df$sk_fit <- df$usd * coefs[1] +
df$gbp * coefs[2] +
df$eur * coefs[3] +
df$brent * coefs[4] +
intercept
# Calcular residuales
df$sk_residual <- df$nok - df$sk_fit
# Cargar librerías necesarias
library(dplyr)
# Establecer umbrales basados en 1 sigma del residual anterior a la fecha corte
residual_std <- sd(df$sk_residual[df$date < as.Date('2017-04-25')])
upper <- residual_std
lower <- -residual_std
# Crear el dataframe de señales a partir del 25 de abril de 2017
signals <- df %>%
filter(date >= as.Date('2017-04-25')) %>%
select(nok, usd, eur, gbp, brent, sk_fit, sk_residual)
# Renombrar la columna sk_fit a fitted
signals <- signals %>%
rename(fitted = sk_fit)
# Agregar columnas de bandas y señales
signals <- signals %>%
mutate(
upper = fitted + upper,
lower = fitted + lower,
`stop profit` = fitted + 2 * upper,
`stop loss` = fitted + 2 * lower,
signals = 0
)
# Aseguramos que 'signals' tenga una columna de señales
signals$signals <- 0
signals$cumsum <- 0  # para rastrear la acumulación de señales
# Ejecutamos el recorrido fila por fila
for (j in 1:nrow(signals)) {
# Aplicamos las reglas de entrada
if (signals$nok[j] > signals$upper[j]) {
signals$signals[j] <- -1  # Señal de venta (short)
}
if (signals$nok[j] < signals$lower[j]) {
signals$signals[j] <- 1   # Señal de compra (long)
}
# Recalculamos cumsum para controlar cantidad de señales activas
signals$cumsum <- cumsum(signals$signals)
# Si el número acumulado de señales supera +/-1, neutralizamos la nueva señal
if (signals$cumsum[j] > 1 || signals$cumsum[j] < -1) {
signals$signals[j] <- 0
signals$cumsum <- cumsum(signals$signals)
}
# STOP PROFIT: si se alcanza el límite superior de ganancia
if (signals$nok[j] > signals$`stop profit`[j]) {
signals$cumsum <- cumsum(signals$signals)
signals$signals[j] <- -signals$cumsum[j] + 1
signals$cumsum <- cumsum(signals$signals)
break  # detenemos el algoritmo
}
# STOP LOSS: si se alcanza el límite inferior de pérdida
if (signals$nok[j] < signals$`stop loss`[j]) {
signals$cumsum <- cumsum(signals$signals)
signals$signals[j] <- -signals$cumsum[j] - 1
signals$cumsum <- cumsum(signals$signals)
break  # detenemos el algoritmo
}
}
install.packages(c("ggplot2", "dplyr"))
# Oil Money NOK Strategy - R Translation
# Load required libraries
library(tidyverse)
library(lubridate)
library(glmnet)
# Load and prepare data
df <- read.csv("data/brent crude nokjpy.csv", check.names = FALSE)
colnames(df)[1] <- "date"
df$date <- as.Date(df$date, format = "%m/%d/%Y")
# Scatter plot NOK vs Brent
df %>%
filter(date < as.Date("2017-04-25")) %>%
ggplot(aes(x = brent, y = nok)) +
geom_point(color = "#5f0f4e", size = 0.8) +
labs(title = "NOK Brent Correlation", x = "Brent in JPY", y = "NOKJPY") +
theme_minimal()
# Dual-axis base plot function (mimics Python twin axes)
dual_base_plot <- function(data, y1_col, y2_col, y1_label, y2_label, title,
col1 = "#34262b", col2 = "#cb2800") {
# Set margins to allow right axis label
par(mar = c(5, 4, 4, 4) + 0.1)
# Plot first series
plot(data$date, data[[y1_col]], type = "l", col = col1,
xlab = "Date", ylab = y1_label, main = title)
# Overlay second series with no axes
par(new = TRUE)
plot(data$date, data[[y2_col]], type = "s", col = col2,
axes = FALSE, xlab = "", ylab = "")
axis(side = 4, col = col2, col.axis = col2)
mtext(y2_label, side = 4, line = 3, col = col2)
legend("bottomright", legend = c(y1_label, y2_label),
col = c(col1, col2), lty = 1, bty = "n")
}
# Use dual_base_plot for relationships
# NOK vs Interest Rate
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "interest rate",
y1_label = "NOKJPY", y2_label = "Interest Rate",
title = "NOK vs Interest Rate"
)
# NOK vs Brent
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "brent",
y1_label = "NOKJPY", y2_label = "Brent in JPY",
title = "NOK vs Brent"
)
# NOK vs GDP (quarterly) - smooth interpolation of GDP values
# Interpolate GDP to daily frequency
gdp_idx    <- which(!is.na(df$`gdp yoy`))
gdp_dates  <- df$date[gdp_idx]
gdp_values <- df$`gdp yoy`[gdp_idx]
# Create interpolation function
gdp_interp_fun <- approxfun(x = as.numeric(gdp_dates), y = gdp_values, method = "linear", rule = 2)
# Apply to all dates
df$gdp_smooth <- gdp_interp_fun(as.numeric(df$date))
# Prepare combined dataframe for plotting
gdp_plot_df <- df %>% filter(date < as.Date("2017-04-25")) %>% select(date, nok, gdp_smooth)
# Plot using dual_base_plot (base R)
dual_base_plot(
gdp_plot_df,
y1_col = "nok", y2_col = "gdp_smooth",
y1_label = "NOKJPY", y2_label = "GDP YoY %",
title = "NOK vs GDP (Interpolated)"
)
# Linear regression (OLS)) (OLS)
x0 <- df %>% select(usd, gbp, eur, brent)
y  <- df$nok
train_idx <- df$date < as.Date("2017-04-25")
ols_model <- lm(y[train_idx] ~ ., data = x0[train_idx, ])
print(summary(ols_model))
library(glmnet)
# Convertimos x0 y filtramos por fecha
fecha_corte <- as.Date('2017-04-25')
x0_filtrado <- as.matrix(subset(x0, index(x0) < fecha_corte))
# Oil Money NOK Strategy - R Translation
# Load required libraries
library(tidyverse)
library(lubridate)
library(glmnet)
# Load and prepare data
df <- read.csv("data/brent crude nokjpy.csv", check.names = FALSE)
colnames(df)[1] <- "date"
df$date <- as.Date(df$date, format = "%m/%d/%Y")
# Scatter plot NOK vs Brent
df %>%
filter(date < as.Date("2017-04-25")) %>%
ggplot(aes(x = brent, y = nok)) +
geom_point(color = "#5f0f4e", size = 0.8) +
labs(title = "NOK Brent Correlation", x = "Brent in JPY", y = "NOKJPY") +
theme_minimal()
# Dual-axis base plot function (mimics Python twin axes)
dual_base_plot <- function(data, y1_col, y2_col, y1_label, y2_label, title,
col1 = "#34262b", col2 = "#cb2800") {
# Set margins to allow right axis label
par(mar = c(5, 4, 4, 4) + 0.1)
# Plot first series
plot(data$date, data[[y1_col]], type = "l", col = col1,
xlab = "Date", ylab = y1_label, main = title)
# Overlay second series with no axes
par(new = TRUE)
plot(data$date, data[[y2_col]], type = "s", col = col2,
axes = FALSE, xlab = "", ylab = "")
axis(side = 4, col = col2, col.axis = col2)
mtext(y2_label, side = 4, line = 3, col = col2)
legend("bottomright", legend = c(y1_label, y2_label),
col = c(col1, col2), lty = 1, bty = "n")
}
# Use dual_base_plot for relationships
# NOK vs Interest Rate
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "interest rate",
y1_label = "NOKJPY", y2_label = "Interest Rate",
title = "NOK vs Interest Rate"
)
# NOK vs Brent
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "brent",
y1_label = "NOKJPY", y2_label = "Brent in JPY",
title = "NOK vs Brent"
)
# NOK vs GDP (quarterly) - smooth interpolation of GDP values
# Interpolate GDP to daily frequency
gdp_idx    <- which(!is.na(df$`gdp yoy`))
gdp_dates  <- df$date[gdp_idx]
gdp_values <- df$`gdp yoy`[gdp_idx]
# Create interpolation function
gdp_interp_fun <- approxfun(x = as.numeric(gdp_dates), y = gdp_values, method = "linear", rule = 2)
# Apply to all dates
df$gdp_smooth <- gdp_interp_fun(as.numeric(df$date))
# Prepare combined dataframe for plotting
gdp_plot_df <- df %>% filter(date < as.Date("2017-04-25")) %>% select(date, nok, gdp_smooth)
# Plot using dual_base_plot (base R)
dual_base_plot(
gdp_plot_df,
y1_col = "nok", y2_col = "gdp_smooth",
y1_label = "NOKJPY", y2_label = "GDP YoY %",
title = "NOK vs GDP (Interpolated)"
)
# Linear regression (OLS)) (OLS)
x0 <- df %>% select(usd, gbp, eur, brent)
y  <- df$nok
train_idx <- df$date < as.Date("2017-04-25")
ols_model <- lm(y[train_idx] ~ ., data = x0[train_idx, ])
print(summary(ols_model))
library(glmnet)
# Convertimos x0 y filtramos por fecha
fecha_corte <- as.Date('2017-04-25')
x0_filtrado <- as.matrix(subset(x0, index(x0) < fecha_corte))
# Oil Money NOK Strategy - R Translation
# Load required libraries
library(tidyverse)
library(lubridate)
library(glmnet)
# Load and prepare data
df <- read.csv("data/brent crude nokjpy.csv", check.names = FALSE)
colnames(df)[1] <- "date"
df$date <- as.Date(df$date, format = "%m/%d/%Y")
# Scatter plot NOK vs Brent
df %>%
filter(date < as.Date("2017-04-25")) %>%
ggplot(aes(x = brent, y = nok)) +
geom_point(color = "#5f0f4e", size = 0.8) +
labs(title = "NOK Brent Correlation", x = "Brent in JPY", y = "NOKJPY") +
theme_minimal()
# Dual-axis base plot function (mimics Python twin axes)
dual_base_plot <- function(data, y1_col, y2_col, y1_label, y2_label, title,
col1 = "#34262b", col2 = "#cb2800") {
# Set margins to allow right axis label
par(mar = c(5, 4, 4, 4) + 0.1)
# Plot first series
plot(data$date, data[[y1_col]], type = "l", col = col1,
xlab = "Date", ylab = y1_label, main = title)
# Overlay second series with no axes
par(new = TRUE)
plot(data$date, data[[y2_col]], type = "s", col = col2,
axes = FALSE, xlab = "", ylab = "")
axis(side = 4, col = col2, col.axis = col2)
mtext(y2_label, side = 4, line = 3, col = col2)
legend("bottomright", legend = c(y1_label, y2_label),
col = c(col1, col2), lty = 1, bty = "n")
}
# Use dual_base_plot for relationships
# NOK vs Interest Rate
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "interest rate",
y1_label = "NOKJPY", y2_label = "Interest Rate",
title = "NOK vs Interest Rate"
)
# NOK vs Brent
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "brent",
y1_label = "NOKJPY", y2_label = "Brent in JPY",
title = "NOK vs Brent"
)
# NOK vs GDP (quarterly) - smooth interpolation of GDP values
# Interpolate GDP to daily frequency
gdp_idx    <- which(!is.na(df$`gdp yoy`))
gdp_dates  <- df$date[gdp_idx]
gdp_values <- df$`gdp yoy`[gdp_idx]
# Create interpolation function
gdp_interp_fun <- approxfun(x = as.numeric(gdp_dates), y = gdp_values, method = "linear", rule = 2)
# Apply to all dates
df$gdp_smooth <- gdp_interp_fun(as.numeric(df$date))
# Prepare combined dataframe for plotting
gdp_plot_df <- df %>% filter(date < as.Date("2017-04-25")) %>% select(date, nok, gdp_smooth)
# Plot using dual_base_plot (base R)
dual_base_plot(
gdp_plot_df,
y1_col = "nok", y2_col = "gdp_smooth",
y1_label = "NOKJPY", y2_label = "GDP YoY %",
title = "NOK vs GDP (Interpolated)"
)
# Linear regression (OLS)) (OLS)
x0 <- df %>% select(usd, gbp, eur, brent)
y  <- df$nok
train_idx <- df$date < as.Date("2017-04-25")
ols_model <- lm(y[train_idx] ~ ., data = x0[train_idx, ])
print(summary(ols_model))
library(glmnet)
# Convertimos x0 y filtramos por fecha
fecha_corte <- as.Date('2017-04-25')
x0_filtrado <- as.matrix(subset(x0, index(x0) < fecha_corte))
# Oil Money NOK Strategy - R Translation
# Load required libraries
library(tidyverse)
library(lubridate)
library(glmnet)
# Load and prepare data
df <- read.csv("data/brent crude nokjpy.csv", check.names = FALSE)
colnames(df)[1] <- "date"
df$date <- as.Date(df$date, format = "%m/%d/%Y")
# Scatter plot NOK vs Brent
df %>%
filter(date < as.Date("2017-04-25")) %>%
ggplot(aes(x = brent, y = nok)) +
geom_point(color = "#5f0f4e", size = 0.8) +
labs(title = "NOK Brent Correlation", x = "Brent in JPY", y = "NOKJPY") +
theme_minimal()
# Dual-axis base plot function (mimics Python twin axes)
dual_base_plot <- function(data, y1_col, y2_col, y1_label, y2_label, title,
col1 = "#34262b", col2 = "#cb2800") {
# Set margins to allow right axis label
par(mar = c(5, 4, 4, 4) + 0.1)
# Plot first series
plot(data$date, data[[y1_col]], type = "l", col = col1,
xlab = "Date", ylab = y1_label, main = title)
# Overlay second series with no axes
par(new = TRUE)
plot(data$date, data[[y2_col]], type = "s", col = col2,
axes = FALSE, xlab = "", ylab = "")
axis(side = 4, col = col2, col.axis = col2)
mtext(y2_label, side = 4, line = 3, col = col2)
legend("bottomright", legend = c(y1_label, y2_label),
col = c(col1, col2), lty = 1, bty = "n")
}
# Use dual_base_plot for relationships
# NOK vs Interest Rate
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "interest rate",
y1_label = "NOKJPY", y2_label = "Interest Rate",
title = "NOK vs Interest Rate"
)
# NOK vs Brent
dual_base_plot(
df %>% filter(date < as.Date("2017-04-25")),
y1_col = "nok", y2_col = "brent",
y1_label = "NOKJPY", y2_label = "Brent in JPY",
title = "NOK vs Brent"
)
# NOK vs GDP (quarterly) - smooth interpolation of GDP values
# Interpolate GDP to daily frequency
gdp_idx    <- which(!is.na(df$`gdp yoy`))
gdp_dates  <- df$date[gdp_idx]
gdp_values <- df$`gdp yoy`[gdp_idx]
# Create interpolation function
gdp_interp_fun <- approxfun(x = as.numeric(gdp_dates), y = gdp_values, method = "linear", rule = 2)
# Apply to all dates
df$gdp_smooth <- gdp_interp_fun(as.numeric(df$date))
# Prepare combined dataframe for plotting
gdp_plot_df <- df %>% filter(date < as.Date("2017-04-25")) %>% select(date, nok, gdp_smooth)
# Plot using dual_base_plot (base R)
dual_base_plot(
gdp_plot_df,
y1_col = "nok", y2_col = "gdp_smooth",
y1_label = "NOKJPY", y2_label = "GDP YoY %",
title = "NOK vs GDP (Interpolated)"
)
# Linear regression (OLS)) (OLS)
x0 <- df %>% select(usd, gbp, eur, brent)
y  <- df$nok
train_idx <- df$date < as.Date("2017-04-25")
ols_model <- lm(y[train_idx] ~ ., data = x0[train_idx, ])
print(summary(ols_model))
library(glmnet)
# Convertimos x0 y filtramos por fecha
fecha_corte <- as.Date('2017-04-25')
x0_filtrado <- as.matrix(subset(x0, index(x0) < fecha_corte))
=======
X      <- oil_df %>% select(cad, wcs, idx)
# Elbow
sse       <- map_dbl(1:7, ~ kmeans(X, .x, nstart = 20)$tot.withinss / 1e4)
a         <- (sse[1] - last(sse)) / (0 - (length(sse) - 1))
b         <- sse[1] - a * 0
perp_dist <- function(x, y) abs((y - a * x - b) / sqrt(a^2 + 1))
distances <- map_dbl(seq_along(sse) - 1, ~ perp_dist(.x, sse[.x + 1]))
elbow_tbl <- tibble(k = 1:7, SSE = sse, Distance = distances)
# Silhouette scores
sil_scores <- map_dbl(2:7,
~ mean(silhouette(kmeans(X, .x, nstart = 20)$cluster,
dist(X))[, 3]))
sil_tbl <- tibble(k = 2:7, Silhouette = sil_scores)
# Final clustering & before/after split
best_k        <- which.max(sil_scores) + 1
set.seed(42)
km            <- kmeans(X, centers = best_k, nstart = 25)
oil_df$class  <- factor(km$cluster)
threshold_idx <- min(which(oil_df$class == as.character(best_k)))
threshold_date<- oil_df$date[threshold_idx]
before_tbl    <- filter(oil_df, idx <= threshold_idx)
after_tbl     <- filter(oil_df, idx >  threshold_idx)
before_r2     <- summary(lm(cad ~ wcs, data = before_tbl))$r.squared
after_r2      <- summary(lm(cad ~ wcs, data = after_tbl))$r.squared
bar_tbl       <- tibble(
Period = c(paste0("Before ", threshold_date),
paste0("After  ",  threshold_date)),
R2     = c(before_r2, after_r2)
)
# 7) Dual‐axis helper ------------------------------------------------------
plot_dual <- function(y1, y2, lab1, lab2, ttl) {
ggplot(oil_df, aes(date)) +
geom_line(aes(y = y1, colour = lab1)) +
geom_line(aes(y = y2, colour = lab2)) +
scale_colour_manual(values = setNames(c("#a5a77f", "#d8dc2c"),
c(lab1, lab2))) +
scale_y_continuous(name = lab1,
sec.axis = sec_axis(~ ., name = lab2)) +
labs(title = ttl, x = NULL, colour = NULL) +
theme_minimal()
}
# 8) Collect all ggplots ---------------------------------------------------
plots <- list()
# (1) R² bar chart
p1 <- ggplot(r2_tbl, aes(variable, r2, fill = variable)) +
geom_col(width = 0.7, show.legend = FALSE) +
scale_fill_manual(values = r2_tbl$color) +
scale_x_discrete(labels = c("Yuan","Sterling","Dollar","Euro","KRW",
"MXN","Gas","WCS","Edmonton","WTI","Gold","Yen")) +
labs(title="Regressions on Loonie", y="R Squared", x="\nRegressors") +
theme_minimal(base_size=13) +
theme(panel.grid=element_blank())
print(p1); plots[[length(plots)+1]] <- recordPlot()
# (2) Normalised currencies
p2 <- curr_tbl %>%
mutate(currency=factor(currency, levels=c("cny","gbp","cad"))) %>%
ggplot(aes(date, value, colour=currency)) +
geom_line() +
scale_colour_manual(
values = c(cny="#77c9d4", gbp="#57bc90", cad="#015249"),
labels = c("Yuan","Sterling","Loonie")
) +
labs(title="Loonie vs Yuan vs Sterling",
x="Date", y="Normalized Value by 100", colour=NULL) +
theme_minimal()
print(p2); plots[[length(plots)+1]] <- recordPlot()
# (3) Crude-blends line
p3 <- ggplot(crude_tbl, aes(date, value, colour=blend)) +
geom_line(alpha=0.5) +
scale_colour_manual(
values = c(wti="#2a78b2", wcs="#7b68ee", edmonton="#110b3c"),
labels = c("WTI","WCS","Edmonton")
) +
labs(title="Crude Oil Blends",
x="Date", y="Normalized Value by 100", colour=NULL) +
theme_minimal()
print(p3); plots[[length(plots)+1]] <- recordPlot()
# (4) Dual‐axis CAD vs WCS (AUD) with aligned scales -----------------------
# precompute scaling factor
ratio_aud <- max(oil_df$wcs, na.rm = TRUE) /
max(oil_df$cad, na.rm = TRUE)
p4 <- ggplot(oil_df, aes(x = date)) +
# Loonie on the primary axis
geom_line(aes(y = cad,   colour = "Canadian Dollar"), size = 1) +
# WCS down-scaled to sit on same axis
geom_line(aes(y = wcs/ratio_aud, colour = "Western Canadian Select"),
size = 1) +
scale_colour_manual(
values = c(
"Canadian Dollar"            = "#a5a77f",
"Western Canadian Select"    = "#d8dc2c"
)
) +
scale_y_continuous(
name     = "Canadian Dollar",
sec.axis = sec_axis(~ . * ratio_aud,
name = "Western Canadian Select")
) +
labs(
title  = "Loonie VS WCS in AUD",
x      = "Date",
colour = NULL
) +
theme_minimal()
print(p4)
plots[[length(plots) + 1]] <- recordPlot()
# (5) Dual‐axis “Loonie vs WCS in USD”
library(scales)
# recompute your ratio as before
ratio <- max(oil_df$wcs  / oil_df$usd, na.rm = TRUE) /
max(oil_df$cad  / oil_df$usd, na.rm = TRUE)
p5 <- ggplot(oil_df, aes(date)) +
# primary CAD(USD)
geom_line(aes(y = cad / usd, colour = "Loonie"), size = 1) +
# secondary WCS(USD) scaled into the same panel
geom_line(aes(y = (wcs / usd) / ratio, colour = "WCS"), size = 1) +
scale_colour_manual(
values = c(Loonie = "#F58220", WCS = "#7B3F00")
) +
scale_y_continuous(
name     = "Canadian Dollar (USD)",
limits   = c(0, 1.0),            # only show CAD between –1
oob      = squish,                # “squish” any out‐of‐bounds points to the nearest limit
sec.axis = sec_axis(
~ . * ratio,
name = "Western Canadian Select (USD)"
)
) +
labs(
title  = "Loonie VS WCS in USD",
x      = "Date",
colour = NULL
) +
theme_minimal()
print(p5)
plots[[length(plots) + 1]] <- recordPlot()
# (6) Elbow method
p6 <- ggplot(elbow_tbl, aes(x=k)) +
geom_line(aes(y=SSE, colour="SSE")) +
geom_line(aes(y=Distance, colour="Distance")) +
scale_colour_manual(values=c(SSE="#116466", Distance="#e85a4f")) +
scale_y_continuous(
name="Sum of Squared Error",
sec.axis=sec_axis(~., name="Perpendicular Distance")
) +
labs(title="Elbow Method for K Means",
x="Numbers of Cluster", colour=NULL) +
theme_minimal()
print(p6); plots[[length(plots)+1]] <- recordPlot()
# (7) Silhouette Analysis
peak <- sil_tbl %>% filter(Silhouette == max(Silhouette))
p7 <- ggplot(sil_tbl, aes(k, Silhouette)) +
geom_step(direction="mid") +
geom_point(data=peak, aes(k, Silhouette), shape="*", size=6) +
labs(title="Silhouette Analysis for K Means",
x="Numbers of Cluster", y="Silhouette Score") +
theme_minimal()
print(p7); plots[[length(plots)+1]] <- recordPlot()
# (8) 3D cluster scatter static  **NEW**
threshold <- max(which(oil_df$class=="1"))
library(scatterplot3d)
s3d <- scatterplot3d(
x     = oil_df$wcs,
y     = oil_df$cad,
z     = as.numeric(oil_df$date),
color = ifelse(oil_df$class=="1", "#faed26", "#46344e"),
pch   = 19, cex.symbols=0.5,
main  = "K Means on Loonie", xlab="WCS", ylab="Loonie", zlab="Date"
)
legend("topright",
legend = c(paste("Before", threshold),
paste("After",  threshold)),
col    = c("#faed26","#46344e"),
pch    = 19, bty="n")
plots[[length(plots)+1]] <- recordPlot()
# (9) Cluster + Regression R² bar chart
before_r2 <- summary(lm(cad ~ wcs, data=oil_df, subset=(class=="1")))$r.squared
after_r2  <- summary(lm(cad ~ wcs, data=oil_df, subset=(class=="2")))$r.squared
bar_df <- tibble(
Stage = c(paste("Before", threshold), paste("After", threshold)),
R2    = c(before_r2, after_r2)
)
p9 <- ggplot(bar_df, aes(Stage, R2, fill=Stage)) +
geom_col(width=0.7, show.legend=FALSE) +
scale_fill_manual(values=c("#f172a1","#a1c3d1")) +
labs(title="Cluster + Regression", y="R Squared") +
theme_minimal() +
theme(panel.grid=element_blank())
print(p9); plots[[length(plots)+1]] <- recordPlot()
# (10)&(11) Prediction-bands by cluster
for(cl in levels(oil_df$class)) {
sub   <- filter(oil_df, class==cl)
split <- initial_split(sub, prop=0.5)
train <- training(split); test <- testing(split)
fit   <- lm(cad ~ wcs, data=train)
fc    <- predict(fit, newdata=test)
sde   <- sd(residuals(fit))
dfp   <- test %>% mutate(Fitted=fc,
U1=fc+sde, L1=fc-sde,
U2=fc+2*sde, L2=fc-2*sde)
p <- ggplot(dfp, aes(date)) +
geom_line(aes(y=Fitted)) +
geom_line(aes(y=cad)) +
geom_ribbon(aes(ymin=L1, ymax=U1), alpha=0.3) +
geom_ribbon(aes(ymin=L2, ymax=U2), alpha=0.2) +
labs(
title=paste(if(cl=="1") "Before" else "After", threshold,
"\nR Squared", sprintf("%.2f%%", summary(fit)$r.squared*100)),
x="Date", y="CADAUD"
) +
theme_minimal()
print(p); plots[[length(plots)+1]] <- recordPlot()
}
# 9) Write out all static ggplots to PNG ----------------------------------
for(i in seq_along(plots)) {
png(file.path(out_folder, sprintf("figure_%02d.png", i)),
width=8, height=6, units="in", res=300)
replayPlot(plots[[i]]); dev.off()
}
# 10) Export the interactive 3D as PNG via webshot ------------------------
html <- file.path(out_folder, "scatter3d.html")
saveWidget(widget = p3d, file = html, selfcontained=TRUE)
webshot(html,
file   = file.path(out_folder, "figure_11_3d_scatter.png"),
vwidth = 800, vheight = 600)
# 0) Ensure webshot is installed for 3D PNG export ------------------------
if (!requireNamespace("webshot", quietly = TRUE)) {
install.packages("webshot")
webshot::install_phantomjs()
}
library(webshot)
# 1) Load libraries --------------------------------------------------------
library(rsample)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(cluster)
library(factoextra)
library(plotly)
library(purrr)
library(htmlwidgets)
# 2) Prepare output folder ------------------------------------------------
base_dir   <- "/Users/jackshephard-thorn/Desktop/RR_Project/Repo/RR_project/Oil Money project/CAD data"
out_folder <- file.path(base_dir, "original_graphs_r")
if (!dir.exists(out_folder)) dir.create(out_folder, recursive = TRUE)
# 3) Load & tidy data -----------------------------------------------------
data_dir <- "/Users/jackshephard-thorn/Desktop/RR_Project/Repo/RR_project/Oil Money project/data"
csv_file <- "wcs crude cadaud.csv"
oil_df <- read_csv(file.path(data_dir, csv_file), show_col_types = FALSE) %>%
mutate(date = as.POSIXct(date, format = "%m/%d/%Y")) %>%
arrange(date) %>%
select(date,
cny, gbp, usd, eur, krw, mxn, gas,
wcs, edmonton, wti, gold, jpy, cad)
# 4) Compute R² for each regressor ----------------------------------------
get_r2 <- function(vec) summary(lm(cad ~ vec, data = oil_df))$r.squared
vars    <- setdiff(names(oil_df), c("date","cad"))
r2_tbl  <- tibble(variable = vars) %>%
mutate(
r2    = map_dbl(variable, ~ get_r2(oil_df[[.x]])),
color = c(rep("#9499a6", 7), "#582a20", "#be7052", "#f2c083", "#9499a6", "#9499a6")
)
# 5) Normalize series ------------------------------------------------------
norm     <- function(x) x / x[1]
curr_tbl <- oil_df %>%
select(date, cad, cny, gbp) %>%
mutate(across(-date, norm)) %>%
pivot_longer(-date, names_to = "currency", values_to = "value")
crude_tbl <- oil_df %>%
select(date, wti, wcs, edmonton) %>%
mutate(across(-date, norm)) %>%
pivot_longer(-date, names_to = "blend", values_to = "value")
# 6) Prepare k-means diagnostics ------------------------------------------
oil_df <- oil_df %>% mutate(idx = row_number())
X      <- oil_df %>% select(cad, wcs, idx)
# Elbow
sse       <- map_dbl(1:7, ~ kmeans(X, .x, nstart = 20)$tot.withinss / 1e4)
a         <- (sse[1] - last(sse)) / (0 - (length(sse) - 1))
b         <- sse[1] - a * 0
perp_dist <- function(x, y) abs((y - a * x - b) / sqrt(a^2 + 1))
distances <- map_dbl(seq_along(sse) - 1, ~ perp_dist(.x, sse[.x + 1]))
elbow_tbl <- tibble(k = 1:7, SSE = sse, Distance = distances)
# Silhouette scores
sil_scores <- map_dbl(2:7,
~ mean(silhouette(kmeans(X, .x, nstart = 20)$cluster,
dist(X))[, 3]))
sil_tbl <- tibble(k = 2:7, Silhouette = sil_scores)
# Final clustering & before/after split
best_k        <- which.max(sil_scores) + 1
set.seed(42)
km            <- kmeans(X, centers = best_k, nstart = 25)
oil_df$class  <- factor(km$cluster)
threshold_idx <- min(which(oil_df$class == as.character(best_k)))
threshold_date<- oil_df$date[threshold_idx]
before_tbl    <- filter(oil_df, idx <= threshold_idx)
after_tbl     <- filter(oil_df, idx >  threshold_idx)
before_r2     <- summary(lm(cad ~ wcs, data = before_tbl))$r.squared
after_r2      <- summary(lm(cad ~ wcs, data = after_tbl))$r.squared
bar_tbl       <- tibble(
Period = c(paste0("Before ", threshold_date),
paste0("After  ",  threshold_date)),
R2     = c(before_r2, after_r2)
)
# 7) Dual‐axis helper ------------------------------------------------------
plot_dual <- function(y1, y2, lab1, lab2, ttl) {
ggplot(oil_df, aes(date)) +
geom_line(aes(y = y1, colour = lab1)) +
geom_line(aes(y = y2, colour = lab2)) +
scale_colour_manual(values = setNames(c("#a5a77f", "#d8dc2c"),
c(lab1, lab2))) +
scale_y_continuous(name = lab1,
sec.axis = sec_axis(~ ., name = lab2)) +
labs(title = ttl, x = NULL, colour = NULL) +
theme_minimal()
}
# 8) Collect all ggplots ---------------------------------------------------
plots <- list()
# (1) R² bar chart
p1 <- ggplot(r2_tbl, aes(variable, r2, fill = variable)) +
geom_col(width = 0.7, show.legend = FALSE) +
scale_fill_manual(values = r2_tbl$color) +
scale_x_discrete(labels = c("Yuan","Sterling","Dollar","Euro","KRW",
"MXN","Gas","WCS","Edmonton","WTI","Gold","Yen")) +
labs(title="Regressions on Loonie", y="R Squared", x="\nRegressors") +
theme_minimal(base_size=13) +
theme(panel.grid=element_blank())
print(p1); plots[[length(plots)+1]] <- recordPlot()
# (2) Normalised currencies
p2 <- curr_tbl %>%
mutate(currency=factor(currency, levels=c("cny","gbp","cad"))) %>%
ggplot(aes(date, value, colour=currency)) +
geom_line() +
scale_colour_manual(
values = c(cny="#77c9d4", gbp="#57bc90", cad="#015249"),
labels = c("Yuan","Sterling","Loonie")
) +
labs(title="Loonie vs Yuan vs Sterling",
x="Date", y="Normalized Value by 100", colour=NULL) +
theme_minimal()
print(p2); plots[[length(plots)+1]] <- recordPlot()
# (3) Crude-blends line
p3 <- ggplot(crude_tbl, aes(date, value, colour=blend)) +
geom_line(alpha=0.5) +
scale_colour_manual(
values = c(wti="#2a78b2", wcs="#7b68ee", edmonton="#110b3c"),
labels = c("WTI","WCS","Edmonton")
) +
labs(title="Crude Oil Blends",
x="Date", y="Normalized Value by 100", colour=NULL) +
theme_minimal()
print(p3); plots[[length(plots)+1]] <- recordPlot()
# (4) Dual‐axis CAD vs WCS (AUD) with aligned scales -----------------------
# precompute scaling factor
ratio_aud <- max(oil_df$wcs, na.rm = TRUE) /
max(oil_df$cad, na.rm = TRUE)
p4 <- ggplot(oil_df, aes(x = date)) +
# Loonie on the primary axis
geom_line(aes(y = cad,   colour = "Canadian Dollar"), size = 1) +
# WCS down-scaled to sit on same axis
geom_line(aes(y = wcs/ratio_aud, colour = "Western Canadian Select"),
size = 1) +
scale_colour_manual(
values = c(
"Canadian Dollar"            = "#a5a77f",
"Western Canadian Select"    = "#d8dc2c"
)
) +
scale_y_continuous(
name     = "Canadian Dollar",
sec.axis = sec_axis(~ . * ratio_aud,
name = "Western Canadian Select")
) +
labs(
title  = "Loonie VS WCS in AUD",
x      = "Date",
colour = NULL
) +
theme_minimal()
print(p4)
plots[[length(plots) + 1]] <- recordPlot()
# (5) Dual‐axis “Loonie vs WCS in USD”
library(scales)
# recompute your ratio as before
ratio <- max(oil_df$wcs  / oil_df$usd, na.rm = TRUE) /
max(oil_df$cad  / oil_df$usd, na.rm = TRUE)
p5 <- ggplot(oil_df, aes(date)) +
# primary CAD(USD)
geom_line(aes(y = cad / usd, colour = "Loonie"), size = 1) +
# secondary WCS(USD) scaled into the same panel
geom_line(aes(y = (wcs / usd) / ratio, colour = "WCS"), size = 1) +
scale_colour_manual(
values = c(Loonie = "#F58220", WCS = "#7B3F00")
) +
scale_y_continuous(
name     = "Canadian Dollar (USD)",
limits   = c(0, 1.0),            # only show CAD between –1
oob      = squish,                # “squish” any out‐of‐bounds points to the nearest limit
sec.axis = sec_axis(
~ . * ratio,
name = "Western Canadian Select (USD)"
)
) +
labs(
title  = "Loonie VS WCS in USD",
x      = "Date",
colour = NULL
) +
theme_minimal()
print(p5)
plots[[length(plots) + 1]] <- recordPlot()
# (6) Elbow method with proper dual‐axis scaling --------------------------
# compute factor to map Distance → SSE
scale_factor <- max(elbow_tbl$SSE,      na.rm = TRUE) /
max(elbow_tbl$Distance, na.rm = TRUE)
p6 <- ggplot(elbow_tbl, aes(x = k)) +
# SSE on primary axis
geom_line(aes(y = SSE, colour = "SSE"), size = 1) +
# Distance scaled up to SSE range
geom_line(aes(y = Distance * scale_factor, colour = "Distance"), size = 1) +
scale_colour_manual(values = c(SSE = "#116466", Distance = "#e85a4f")) +
scale_y_continuous(
name     = "Sum of Squared Error",
# secondary axis undoes the scaling
sec.axis = sec_axis(~ . / scale_factor,
name = "Perpendicular Distance")
) +
labs(
title  = "Elbow Method for K Means",
x      = "Numbers of Cluster",
colour = NULL
) +
theme_minimal(base_size = 13)
print(p6)
plots[[length(plots) + 1]] <- recordPlot()
# (7) Silhouette Analysis
peak <- sil_tbl %>% filter(Silhouette == max(Silhouette))
p7 <- ggplot(sil_tbl, aes(k, Silhouette)) +
geom_step(direction="mid") +
geom_point(data=peak, aes(k, Silhouette), shape="*", size=6) +
labs(title="Silhouette Analysis for K Means",
x="Numbers of Cluster", y="Silhouette Score") +
theme_minimal()
print(p7); plots[[length(plots)+1]] <- recordPlot()
# (8) 3D cluster scatter static  **NEW**
threshold <- max(which(oil_df$class=="1"))
library(scatterplot3d)
s3d <- scatterplot3d(
x     = oil_df$wcs,
y     = oil_df$cad,
z     = as.numeric(oil_df$date),
color = ifelse(oil_df$class=="1", "#faed26", "#46344e"),
pch   = 19, cex.symbols=0.5,
main  = "K Means on Loonie", xlab="WCS", ylab="Loonie", zlab="Date"
)
legend("topright",
legend = c(paste("Before", threshold),
paste("After",  threshold)),
col    = c("#faed26","#46344e"),
pch    = 19, bty="n")
plots[[length(plots)+1]] <- recordPlot()
# (9) Cluster + Regression R² bar chart
before_r2 <- summary(lm(cad ~ wcs, data=oil_df, subset=(class=="1")))$r.squared
after_r2  <- summary(lm(cad ~ wcs, data=oil_df, subset=(class=="2")))$r.squared
bar_df <- tibble(
Stage = c(paste("Before", threshold), paste("After", threshold)),
R2    = c(before_r2, after_r2)
)
p9 <- ggplot(bar_df, aes(Stage, R2, fill=Stage)) +
geom_col(width=0.7, show.legend=FALSE) +
scale_fill_manual(values=c("#f172a1","#a1c3d1")) +
labs(title="Cluster + Regression", y="R Squared") +
theme_minimal() +
theme(panel.grid=element_blank())
print(p9); plots[[length(plots)+1]] <- recordPlot()
# (10)&(11) Prediction-bands by cluster
for(cl in levels(oil_df$class)) {
sub   <- filter(oil_df, class==cl)
split <- initial_split(sub, prop=0.5)
train <- training(split); test <- testing(split)
fit   <- lm(cad ~ wcs, data=train)
fc    <- predict(fit, newdata=test)
sde   <- sd(residuals(fit))
dfp   <- test %>% mutate(Fitted=fc,
U1=fc+sde, L1=fc-sde,
U2=fc+2*sde, L2=fc-2*sde)
p <- ggplot(dfp, aes(date)) +
geom_line(aes(y=Fitted)) +
geom_line(aes(y=cad)) +
geom_ribbon(aes(ymin=L1, ymax=U1), alpha=0.3) +
geom_ribbon(aes(ymin=L2, ymax=U2), alpha=0.2) +
labs(
title=paste(if(cl=="1") "Before" else "After", threshold,
"\nR Squared", sprintf("%.2f%%", summary(fit)$r.squared*100)),
x="Date", y="CADAUD"
) +
theme_minimal()
print(p); plots[[length(plots)+1]] <- recordPlot()
}
# 9) Write out all static ggplots to PNG ----------------------------------
for(i in seq_along(plots)) {
png(file.path(out_folder, sprintf("figure_%02d.png", i)),
width=8, height=6, units="in", res=300)
replayPlot(plots[[i]]); dev.off()
}
# 10) Export the interactive 3D as PNG via webshot ------------------------
html <- file.path(out_folder, "scatter3d.html")
saveWidget(widget = p3d, file = html, selfcontained=TRUE)
webshot(html,
file   = file.path(out_folder, "figure_11_3d_scatter.png"),
vwidth = 800, vheight = 600)
>>>>>>> jack-branch
